/*
 *     Copyright (C) 2019  Filippo Scognamiglio
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "shadermanager.h"

namespace libretrodroid {

const std::string ShaderManager::defaultShaderVertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform vec2 textureSize;\n"
    "\n"
    "varying mediump float screenMaskStrength;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "void main() {\n"
    "  coords = vCoordinate;\n"
    "  screenCoords = coords * textureSize;\n"
    "  screenMaskStrength = smoothstep(2.0, 6.0, screenDensity);\n"
    "  gl_Position = vPosition;\n"
    "}\n";

const std::string ShaderManager::defaultShaderFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "varying HIGHP vec2 coords;\n"
    "void main() {\n"
    "  lowp vec4 tex = texture2D(texture, coords);"
    "  gl_FragColor = vec4(tex.rgb, 1.0);\n"
    "}\n";

const std::string ShaderManager::crtShaderFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying mediump float screenMaskStrength;\n"
    "\n"
    "#define INTENSITY 0.30\n"
    "#define BRIGHTBOOST 0.30\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 texel = texture2D(texture, coords).rgb;\n"
    "  lowp vec3 pixelHigh = ((1.0 + BRIGHTBOOST) - (0.2 * texel)) * texel;\n"
    "  lowp vec3 pixelLow  = ((1.0 - INTENSITY) + (0.1 * texel)) * texel;\n"
    "\n"
    "  HIGHP vec2 coords = fract(screenCoords) * 2.0 - vec2(1.0);\n"
    "\n"
    "  lowp float mask = 1.0 - abs(coords.y);\n"
    "\n"
    "  gl_FragColor = vec4(mix(texel, mix(pixelLow, pixelHigh, mask), screenMaskStrength), 1.0);\n"
    "}\n";

const std::string ShaderManager::lcdShaderFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying mediump float screenMaskStrength;\n"
    "\n"
    "#define INTENSITY 0.25\n"
    "#define BRIGHTBOOST 0.25\n"
    "\n"
    "void main() {\n"
    "  mediump vec2 threshold = vec2(1.0 / screenDensity);\n"
    "  mediump vec2 x = fract(screenCoords);\n"
    "  x = 0.5 * (smoothstep(vec2(0.0), threshold, x) + smoothstep(vec2(1.0) - threshold, vec2(1.0), x));\n"
    "  mediump vec2 sharpCoords = (floor(screenCoords) + x) / textureSize;\n"
    "\n"
    "  lowp vec3 texel = texture2D(texture, sharpCoords).rgb;\n"
    "  lowp vec3 pixelHigh = ((1.0 + BRIGHTBOOST) - (0.2 * texel)) * texel;\n"
    "  lowp vec3 pixelLow  = ((1.0 - INTENSITY) + (0.1 * texel)) * texel;\n"
    "\n"
    "  HIGHP vec2 coords = fract(screenCoords) * 2.0 - vec2(1.0);\n"
    "  coords = coords * coords;\n"
    "\n"
    "  lowp float mask = 1.0 - coords.x - coords.y;\n"
    "\n"
    "  gl_FragColor = vec4(mix(texel, mix(pixelLow, pixelHigh, mask), screenMaskStrength), 1.0);\n"
    "}\n";

const std::string ShaderManager::defaultSharpFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "\n"
    "void main() {\n"
    "  mediump vec2 threshold = vec2(1.0 / screenDensity);\n"
    "  mediump vec2 x = fract(screenCoords);\n"
    "  x = 0.5 * (smoothstep(vec2(0.0), threshold, x) + smoothstep(vec2(1.0) - threshold, vec2(1.0), x));\n"
    "  mediump vec2 sharpCoords = (floor(screenCoords) + x) / textureSize;\n"
    "\n"
    "  vec4 tex = texture2D(texture, sharpCoords);\n"
    "  gl_FragColor = vec4(tex.rgb, 1.0);\n"
    "}\n";

const std::unordered_map<std::string, std::string> ShaderManager::cutUpscaleParams = {
    { "USE_DYNAMIC_BLEND", "1" },
    { "BLEND_MIN_CONTRAST_EDGE", "0.25" },
    { "BLEND_MAX_CONTRAST_EDGE", "0.75" },
    { "BLEND_MIN_SHARPNESS", "0.0" },
    { "BLEND_MAX_SHARPNESS", "1.0" },
    { "STATIC_BLEND_SHARPNESS", "1.0" },
    { "EDGE_USE_FAST_LUMA", "0" },
    { "EDGE_MIN_VALUE", "0.03" },
    { "EDGE_MIN_CONTRAST", "2.0" },
};

const std::string ShaderManager::cutUpscaleVertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c06 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c09 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cutUpscaleFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "#define EPSILON 0.02\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "lowp float luma(lowp vec3 v) {\n"
    "#if EDGE_USE_FAST_LUMA\n"
    "  lowp float result = v.g;\n"
    "#else\n"
    "  lowp float result = dot(v, vec3(0.299, 0.587, 0.114));\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "struct Pixels {\n"
    "  lowp vec3 p0;\n"
    "  lowp vec3 p1;\n"
    "  lowp vec3 p2;\n"
    "  lowp vec3 p3;\n"
    "};\n"
    "\n"
    "struct Pattern {\n"
    "  Pixels pixels;\n"
    "  bool triangle;\n"
    "  lowp vec2 coords;\n"
    "};\n"
    "\n"
    "lowp vec3 triangle(lowp vec2 pxCoords) {\n"
    "  lowp vec3 ws = vec3(0.0);\n"
    "  ws.x = pxCoords.y - pxCoords.x;\n"
    "  ws.y = 1.0 - ws.x;\n"
    "  ws.z = (pxCoords.y - ws.x) / (ws.y + EPSILON);\n"
    "  return ws;\n"
    "}\n"
    "\n"
    "lowp vec3 quad(lowp vec2 pxCoords) {\n"
    "  return vec3(pxCoords.x, pxCoords.x, pxCoords.y);\n"
    "}\n"
    "\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0 + EPSILON), 0.0, 1.0);\n"
    "}\n"
    "\n"
    "lowp float sharpSmooth(lowp float t, lowp float sharpness) {\n"
    "  return linearStep(sharpness, 1.0 - sharpness, t);\n"
    "}\n"
    "\n"
    "lowp float sharpness(lowp float l1, lowp float l2) {\n"
    "#if USE_DYNAMIC_BLEND\n"
    "  lowp float lumaDiff = abs(l1 - l2);\n"
    "  lowp float contrast = linearStep(BLEND_MIN_CONTRAST_EDGE, BLEND_MAX_CONTRAST_EDGE, lumaDiff);\n"
    "  lowp float result = mix(BLEND_MIN_SHARPNESS * 0.5, BLEND_MAX_SHARPNESS * 0.5, contrast);\n"
    "#else\n"
    "  lowp float result = STATIC_BLEND_SHARPNESS * 0.5;\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "bool hasDiagonal(lowp float a, lowp float b, lowp float c, lowp float d) {\n"
    "  return max(distance(a, d) * EDGE_MIN_CONTRAST, EDGE_MIN_VALUE) < distance(b, c);\n"
    "}\n"
    "\n"
    "lowp vec3 blend(lowp vec3 a, lowp vec3 b, lowp float t) {\n"
    "  return mix(a, b, sharpSmooth(t, sharpness(luma(a), luma(b))));\n"
    "}\n"
    "\n"
    "Pattern pattern0(Pixels pixels, lowp vec2 pxCoords) {\n"
    "  return Pattern(pixels, false, pxCoords);\n"
    "}\n"
    "\n"
    "Pattern pattern1(Pixels pixels, lowp vec2 pxCoords) {\n"
    "  Pattern result;\n"
    "  if (pxCoords.y > pxCoords.x) {\n"
    "    result.pixels = Pixels(pixels.p0, pixels.p2, pixels.p2, pixels.p3);\n"
    "    result.triangle = true;\n"
    "    result.coords = vec2(pxCoords.x, pxCoords.y);\n"
    "  } else {\n"
    "    result.pixels = Pixels(pixels.p0, pixels.p1, pixels.p1, pixels.p3);\n"
    "    result.triangle = true;\n"
    "    result.coords = vec2(pxCoords.y, pxCoords.x);\n"
    "  }\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t05 = texture2D(texture, c05).rgb;\n"
    "  lowp vec3 t06 = texture2D(texture, c06).rgb;\n"
    "  lowp vec3 t09 = texture2D(texture, c09).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "\n"
    "  lowp float l05 = luma(t05);\n"
    "  lowp float l06 = luma(t06);\n"
    "  lowp float l09 = luma(t09);\n"
    "  lowp float l10 = luma(t10);\n"
    "\n"
    "  Pixels pixels = Pixels(t05, t06, t09, t10);\n"
    "\n"
    "  bool d05_10 = hasDiagonal(l05, l06, l09, l10);\n"
    "  bool d06_09 = hasDiagonal(l06, l05, l10, l09);\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "\n"
    "  if (d06_09) {\n"
    "    pixels = Pixels(pixels.p1, pixels.p0, pixels.p3, pixels.p2);\n"
    "    pxCoords.x = 1.0 - pxCoords.x;\n"
    "  }\n"
    "\n"
    "  Pattern pattern;\n"
    "\n"
    "  if (d05_10 || d06_09) {\n"
    "    pattern = pattern1(pixels, pxCoords);\n"
    "  } else {\n"
    "    pattern = pattern0(pixels, pxCoords);\n"
    "  }\n"
    "\n"
    "  lowp vec3 weights = pattern.triangle ? triangle(pattern.coords) : quad(pattern.coords);\n"
    "\n"
    "  lowp vec3 final = blend(\n"
    "    blend(pattern.pixels.p0, pattern.pixels.p1, weights.x),\n"
    "    blend(pattern.pixels.p2, pattern.pixels.p3, weights.y),\n"
    "    weights.z\n"
    "  );\n"
    "\n"
    "  gl_FragColor = vec4(final, 1.0);\n"
    "}";

const std::unordered_map<std::string, std::string> ShaderManager::cut2UpscaleParams = {
    { "USE_DYNAMIC_BLEND", "1" },
    { "BLEND_MIN_CONTRAST_EDGE", "0.00" },
    { "BLEND_MAX_CONTRAST_EDGE", "0.50" },
    { "BLEND_MIN_SHARPNESS", "0.0" },
    { "BLEND_MAX_SHARPNESS", "0.75" },
    { "STATIC_BLEND_SHARPNESS", "0.00" },
    { "EDGE_USE_FAST_LUMA", "0" },
    { "EDGE_MIN_VALUE", "0.05" },
    { "SOFT_EDGES_SHARPENING", "1" },
    { "SOFT_EDGES_SHARPENING_AMOUNT", "0.75" },
    { "HARD_EDGES_THRESHOLD", "0.2" },
};

const std::string ShaderManager::cut2UpscalePass0Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 c01;\n"
    "varying HIGHP vec2 c02;\n"
    "varying HIGHP vec2 c04;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c07;\n"
    "varying HIGHP vec2 c08;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "varying HIGHP vec2 c11;\n"
    "varying HIGHP vec2 c13;\n"
    "varying HIGHP vec2 c14;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  HIGHP vec2 screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c01 = (screenCoords + vec2(+0.0, -1.0)) / textureSize;\n"
    "  c02 = (screenCoords + vec2(+1.0, -1.0)) / textureSize;\n"
    "  c04 = (screenCoords + vec2(-1.0, +0.0)) / textureSize;\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c06 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c07 = (screenCoords + vec2(+2.0, +0.0)) / textureSize;\n"
    "  c08 = (screenCoords + vec2(-1.0, +1.0)) / textureSize;\n"
    "  c09 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  c11 = (screenCoords + vec2(+2.0, +1.0)) / textureSize;\n"
    "  c13 = (screenCoords + vec2(+0.0, +2.0)) / textureSize;\n"
    "  c14 = (screenCoords + vec2(+1.0, +2.0)) / textureSize;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cut2UpscalePass0Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "#define EPSILON 0.02\n"
    "\n"
    "precision lowp float;\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "\n"
    "varying HIGHP vec2 c01;\n"
    "varying HIGHP vec2 c02;\n"
    "varying HIGHP vec2 c04;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c07;\n"
    "varying HIGHP vec2 c08;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "varying HIGHP vec2 c11;\n"
    "varying HIGHP vec2 c13;\n"
    "varying HIGHP vec2 c14;\n"
    "\n"
    "lowp float maxOf(lowp vec4 values) {\n"
    "  return max(max(values.x, values.y), max(values.z, values.w));\n"
    "}\n"
    "\n"
    "lowp float luma(lowp vec3 v) {\n"
    "#if EDGE_USE_FAST_LUMA\n"
    "  lowp float result = v.g;\n"
    "#else\n"
    "  lowp float result = dot(v, vec3(0.299, 0.587, 0.114));\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp float quickPackBools2(bvec2 values) {\n"
    "  return dot(vec2(values), vec2(0.5, 0.25));\n"
    "}\n"
    "\n"
    "lowp float quickPackFloats2(lowp vec2 values) {\n"
    "  return dot(floor(values * vec2(12.0) + vec2(0.5)), vec2(0.0625, 0.00390625));\n"
    "}\n"
    "\n"
    "struct Quad {\n"
    "  lowp vec4 scores;\n"
    "};\n"
    "\n"
    "Quad quad(lowp vec4 values) {\n"
    "  lowp vec4 edges = values.xyzx - values.ywwz;\n"
    "\n"
    "  Quad result;\n"
    "  result.scores = vec4(\n"
    "    abs(edges.x + edges.z),\n"
    "    abs(edges.w + edges.y),\n"
    "    max(abs(edges.x - edges.y), abs(edges.w - edges.z)),\n"
    "    max(abs(edges.x + edges.w), abs(edges.y + edges.z))\n"
    "  );\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp int computePattern(lowp vec4 scores, lowp vec4 neighborsScores) {\n"
    "  lowp float maxOrthogonal = max(scores.x, scores.y);\n"
    "  lowp float maxDiagonal = max(scores.z, scores.w);\n"
    "\n"
    "  bool isDiagonal = maxDiagonal > maxOrthogonal;\n"
    "\n"
    "  scores += 0.25 * neighborsScores;\n"
    "\n"
    "  lowp int result = 0;\n"
    "  if (!isDiagonal) {\n"
    "    if (scores.x > scores.y + EDGE_MIN_VALUE) {\n"
    "      result = 1;\n"
    "    } else if (scores.y > scores.x + EDGE_MIN_VALUE) {\n"
    "      result = 2;\n"
    "    }\n"
    "  } else {\n"
    "    if (scores.z > scores.w + EDGE_MIN_VALUE) {\n"
    "      result = 3;\n"
    "    } else if (scores.w > scores.z + EDGE_MIN_VALUE) {\n"
    "      result = 4;\n"
    "    }\n"
    "  }\n"
    "\n"
    "  lowp vec2 maxScores = isDiagonal ? vec2(maxOrthogonal, maxDiagonal) : vec2(maxDiagonal, maxOrthogonal);\n"
    "  if (maxScores.y <= max((1.0 + HARD_EDGES_THRESHOLD) * maxScores.x, EDGE_MIN_VALUE)) {\n"
    "    result = -result;\n"
    "  }\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp int findPattern(Quad quad) {\n"
    "  return computePattern(quad.scores, vec4(0.0));\n"
    "}\n"
    "\n"
    "lowp int findPattern(Quad quads[5]) {\n"
    "  lowp vec4 adjustments = vec4(0.0);\n"
    "  adjustments += quads[1].scores;\n"
    "  adjustments += quads[2].scores;\n"
    "  adjustments += quads[3].scores;\n"
    "  adjustments += quads[4].scores;\n"
    "  return computePattern(quads[0].scores, adjustments);\n"
    "}\n"
    "\n"
    "lowp float softEdgeWeight(lowp float a, lowp float b, lowp float c, lowp float d) {\n"
    "  lowp float result = 0.0;\n"
    "  lowp float diff = abs(b - c);\n"
    "  result += (diff / clamp(abs(a - c), diff + EPSILON, 1.0));\n"
    "  result -= (diff / clamp(abs(b - d), diff + EPSILON, 1.0));\n"
    "  return clamp(2.0 * result, -1.0, 1.0);\n"
    "}\n"
    "\n"
    "lowp float hardEdgeWeight(lowp int cp, lowp int np, lowp int vertical, lowp int positiveDiagonal, lowp int negativeDiagonal) {\n"
    "  lowp float result = 0.0;\n"
    "  if ((cp == vertical && np == positiveDiagonal) || (np == vertical && cp == negativeDiagonal)) {\n"
    "    result = 0.5;\n"
    "  } else if ((cp == vertical && np == negativeDiagonal) || (np == vertical && cp == positiveDiagonal)) {\n"
    "    result = -0.5;\n"
    "  }\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t01 = texture2D(texture, c01).rgb;\n"
    "  lowp vec3 t02 = texture2D(texture, c02).rgb;\n"
    "  lowp vec3 t04 = texture2D(texture, c04).rgb;\n"
    "  lowp vec3 t05 = texture2D(texture, c05).rgb;\n"
    "  lowp vec3 t06 = texture2D(texture, c06).rgb;\n"
    "  lowp vec3 t07 = texture2D(texture, c07).rgb;\n"
    "  lowp vec3 t08 = texture2D(texture, c08).rgb;\n"
    "  lowp vec3 t09 = texture2D(texture, c09).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "  lowp vec3 t11 = texture2D(texture, c11).rgb;\n"
    "  lowp vec3 t13 = texture2D(texture, c13).rgb;\n"
    "  lowp vec3 t14 = texture2D(texture, c14).rgb;\n"
    "\n"
    "  lowp float l01 = luma(t01);\n"
    "  lowp float l02 = luma(t02);\n"
    "  lowp float l04 = luma(t04);\n"
    "  lowp float l05 = luma(t05);\n"
    "  lowp float l06 = luma(t06);\n"
    "  lowp float l07 = luma(t07);\n"
    "  lowp float l08 = luma(t08);\n"
    "  lowp float l09 = luma(t09);\n"
    "  lowp float l10 = luma(t10);\n"
    "  lowp float l11 = luma(t11);\n"
    "  lowp float l13 = luma(t13);\n"
    "  lowp float l14 = luma(t14);\n"
    "\n"
    "  Quad quads[5];\n"
    "  quads[0] = quad(vec4(l05, l06, l09, l10));\n"
    "  quads[1] = quad(vec4(l01, l02, l05, l06));\n"
    "  quads[2] = quad(vec4(l06, l07, l10, l11));\n"
    "  quads[3] = quad(vec4(l09, l10, l13, l14));\n"
    "  quads[4] = quad(vec4(l04, l05, l08, l09));\n"
    "\n"
    "  lowp int pattern = findPattern(quads[0]);\n"
    "\n"
    "  lowp ivec4 neighbors = ivec4(findPattern(quads[1]), findPattern(quads[2]), findPattern(quads[3]), findPattern(quads[4]));\n"
    "\n"
    "  lowp vec4 edges = vec4(\n"
    "    hardEdgeWeight(pattern, neighbors.x, 1, 4, 3),\n"
    "    hardEdgeWeight(pattern, neighbors.y, 2, 3, 4),\n"
    "    hardEdgeWeight(pattern, neighbors.z, 1, 3, 4),\n"
    "    hardEdgeWeight(pattern, neighbors.w, 2, 4, 3)\n"
    "  );\n"
    "\n"
    "#if SOFT_EDGES_SHARPENING\n"
    "  lowp vec4 softEdges = SOFT_EDGES_SHARPENING_AMOUNT * vec4(\n"
    "    softEdgeWeight(l04, l05, l06, l07),\n"
    "    softEdgeWeight(l02, l06, l10, l14),\n"
    "    softEdgeWeight(l08, l09, l10, l11),\n"
    "    softEdgeWeight(l01, l05, l09, l13)\n"
    "  );\n"
    "\n"
    "  edges = clamp(edges + softEdges, min(edges, softEdges), max(edges, softEdges));\n"
    "#endif\n"
    "\n"
    "  pattern = findPattern(quads);\n"
    "  pattern = pattern > 0 ? pattern : -pattern;\n"
    "\n"
    "  if (pattern == 3) {\n"
    "    edges = vec4(-edges.x, edges.w, -edges.z, edges.y);\n"
    "  }\n"
    "\n"
    "  lowp vec4 result = vec4(\n"
    "    quickPackBools2(bvec2(pattern >= 3, pattern == 3)),\n"
    "    quickPackFloats2(edges.xy * 0.5 + vec2(0.5)),\n"
    "    quickPackFloats2(edges.zw * 0.5 + vec2(0.5)),\n"
    "    1.0\n"
    "  );\n"
    "\n"
    "  gl_FragColor = result;\n"
    "}";

const std::string ShaderManager::cut2UpscalePass1Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying lowp float cutMaxSharpness;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "void main() {\n"
    "  cutMaxSharpness = clamp(1.0 - 1.0 / screenDensity, 0.0, 1.0);\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c06 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c09 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  passCoords = c05;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cut2UpscalePass1Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "#define EPSILON 0.02\n"
    "\n"
    "precision lowp float;\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "uniform lowp sampler2D previousPass;\n"
    "\n"
    "varying lowp float cutMaxSharpness;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return v.g;\n"
    "}\n"
    "\n"
    "struct Pixels {\n"
    "  lowp vec3 p0;\n"
    "  lowp vec3 p1;\n"
    "  lowp vec3 p2;\n"
    "  lowp vec3 p3;\n"
    "};\n"
    "\n"
    "struct ShapeWeights {\n"
    "  lowp vec3 weights;\n"
    "  lowp vec3 midPoints;\n"
    "};\n"
    "\n"
    "struct Pattern {\n"
    "  Pixels pixels;\n"
    "  lowp vec3 weights;\n"
    "  lowp vec3 midPoints;\n"
    "  lowp vec3 baseSharpness;\n"
    "};\n"
    "\n"
    "struct Flags {\n"
    "  bool flip;\n"
    "  bool triangle;\n"
    "  lowp vec4 edgeWeight;\n"
    "};\n"
    "\n"
    "lowp vec2 quickUnpackFloats2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return result / 12.0;\n"
    "}\n"
    "\n"
    "bvec2 quickUnpackBools2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return greaterThan(result, vec2(0.5));\n"
    "}\n"
    "\n"
    "Flags parseFlags(lowp vec3 flagsPixel) {\n"
    "  Flags flags;\n"
    "  flags.edgeWeight = clamp(\n"
    "    vec4(quickUnpackFloats2(flagsPixel.y + 0.001953125), quickUnpackFloats2(flagsPixel.z + 0.001953125)),\n"
    "    EPSILON,\n"
    "    1.0 - EPSILON\n"
    "  );\n"
    "  bvec2 boolFlags = quickUnpackBools2(flagsPixel.x + 0.125);\n"
    "  flags.triangle = boolFlags.x;\n"
    "  flags.flip = boolFlags.y;\n"
    "  return flags;\n"
    "}\n"
    "\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n"
    "}\n"
    "\n"
    "lowp float sharpness(lowp float l1, lowp float l2) {\n"
    "#if USE_DYNAMIC_BLEND\n"
    "  const lowp float blendDiffInv = 1.0 / (BLEND_MAX_CONTRAST_EDGE - BLEND_MIN_CONTRAST_EDGE);\n"
    "  lowp float lumaDiff = abs(l1 - l2);\n"
    "  lowp float contrast = clamp((lumaDiff - BLEND_MIN_CONTRAST_EDGE) * blendDiffInv, 0.0, 1.0);\n"
    "  lowp float result = mix(BLEND_MIN_SHARPNESS * 0.5, BLEND_MAX_SHARPNESS * 0.5, contrast);\n"
    "#else\n"
    "  lowp float result = STATIC_BLEND_SHARPNESS * 0.5;\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp float adjustMidpoint(lowp float x, lowp float midPoint) {\n"
    "  lowp float result = 0.0;\n"
    "  result += clamp(x / midPoint, 0.0, 1.0);\n"
    "  result += clamp((x - midPoint) / (1.0 - midPoint), 0.0, 1.0);\n"
    "  return 0.5 * result;\n"
    "}\n"
    "\n"
    "lowp vec3 blend(lowp vec3 a, lowp vec3 b, lowp float t, lowp float midPoint, lowp float baseSharpness) {\n"
    "  lowp float sharpness = baseSharpness * sharpness(luma(a), luma(b));\n"
    "  lowp float nt = adjustMidpoint(t, midPoint);\n"
    "  nt = clamp((nt - sharpness) / (1.0 - 2.0 * sharpness), 0.0 , 1.0);\n"
    "  return mix(a, b, nt);\n"
    "}\n"
    "\n"
    "Pattern pattern(Pixels pixels, lowp vec4 edgeWeights, bool triangle, lowp vec2 pxCoords) {\n"
    "  Pattern result;\n"
    "\n"
    "  bool firstTriangle = triangle && pxCoords.x + pxCoords.y <= 1.0;\n"
    "  bool secondTriangle = triangle && !firstTriangle;\n"
    "\n"
    "  lowp vec2 midPoints = vec2(0.0);\n"
    "\n"
    "  if (secondTriangle) {\n"
    "    pxCoords = vec2(1.0 - pxCoords.y, 1.0 - pxCoords.x);\n"
    "    pixels = Pixels(pixels.p3, pixels.p1, pixels.p2, pixels.p0);\n"
    "    edgeWeights = vec4(1.0) - edgeWeights.yxwz;\n"
    "  }\n"
    "\n"
    "  if (triangle) {\n"
    "    lowp float coordsSum = pxCoords.x + pxCoords.y;\n"
    "    midPoints = vec2(\n"
    "    edgeWeights.x * edgeWeights.w * coordsSum / (edgeWeights.w * pxCoords.x + edgeWeights.x * pxCoords.y),\n"
    "    0.5 + 0.5 * clamp(-edgeWeights.x + edgeWeights.y - edgeWeights.z + edgeWeights.w, -1.0, 1.0)\n"
    "    );\n"
    "    pxCoords = vec2(coordsSum, pxCoords.y / coordsSum);\n"
    "  } else {\n"
    "    midPoints = vec2(\n"
    "    mix(edgeWeights.x, edgeWeights.z, pxCoords.y),\n"
    "    mix(edgeWeights.w, edgeWeights.y, pxCoords.x)\n"
    "    );\n"
    "  }\n"
    "\n"
    "  result.weights = pxCoords.xxy;\n"
    "  result.midPoints = midPoints.xxy;\n"
    "  result.baseSharpness = vec3(1.0, 1.0, float(!triangle));\n"
    "  result.pixels = Pixels(\n"
    "    pixels.p0,\n"
    "    pixels.p1,\n"
    "    triangle ? pixels.p0 : pixels.p2,\n"
    "    triangle ? pixels.p2 : pixels.p3\n"
    "  );\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t05 = texture2D(texture, c05).rgb;\n"
    "  lowp vec3 t06 = texture2D(texture, c06).rgb;\n"
    "  lowp vec3 t09 = texture2D(texture, c09).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "\n"
    "  lowp vec3 flagsPixel = texture2D(previousPass, passCoords).xyz;\n"
    "  Flags flags = parseFlags(flagsPixel);\n"
    "  Pixels pixels = Pixels(t05, t06, t09, t10);\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "  lowp vec4 edges = flags.edgeWeight;\n"
    "\n"
    "  if (flags.flip) {\n"
    "    pixels = Pixels(pixels.p1, pixels.p0, pixels.p3, pixels.p2);\n"
    "    pxCoords.x = 1.0 - pxCoords.x;\n"
    "  }\n"
    "\n"
    "  Pattern pattern = pattern(pixels, edges, flags.triangle, pxCoords);\n"
    "\n"
    "  lowp vec3 final = blend(\n"
    "    blend(pattern.pixels.p0, pattern.pixels.p1, pattern.weights.x, pattern.midPoints.x, pattern.baseSharpness.x),\n"
    "    blend(pattern.pixels.p2, pattern.pixels.p3, pattern.weights.y, pattern.midPoints.y, pattern.baseSharpness.y),\n"
    "    pattern.weights.z,\n"
    "    pattern.midPoints.z,\n"
    "    pattern.baseSharpness.z\n"
    "  );\n"
    "\n"
    "  gl_FragColor = vec4(final.rgb, 1.0);\n"
    "}";

const std::unordered_map<std::string, std::string> ShaderManager::cut3UpscaleParams = {
    { "USE_DYNAMIC_BLEND", "1" },
    { "BLEND_MIN_CONTRAST_EDGE", "0.00" },
    { "BLEND_MAX_CONTRAST_EDGE", "0.50" },
    { "BLEND_MIN_SHARPNESS", "0.0" },
    { "BLEND_MAX_SHARPNESS", "0.75" },
    { "STATIC_BLEND_SHARPNESS", "0.00" },
    { "EDGE_USE_FAST_LUMA", "0" },
    { "EDGE_MIN_VALUE", "0.05" },
    { "SOFT_EDGES_SHARPENING", "1" },
    { "SOFT_EDGES_SHARPENING_AMOUNT", "0.75" },
    { "HARD_EDGES_THRESHOLD", "0.2" },
    { "HARD_EDGES_SEARCH_MIN_CONTRAST", "0.5" },
    { "HARD_EDGES_SEARCH_MAX_DISTANCE", "4" },
};

const std::string ShaderManager::cut3UpscalePass0Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 c01;\n"
    "varying HIGHP vec2 c02;\n"
    "varying HIGHP vec2 c04;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c07;\n"
    "varying HIGHP vec2 c08;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "varying HIGHP vec2 c11;\n"
    "varying HIGHP vec2 c13;\n"
    "varying HIGHP vec2 c14;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  HIGHP vec2 screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c01 = (screenCoords + vec2(+0.0, -1.0)) / textureSize;\n"
    "  c02 = (screenCoords + vec2(+1.0, -1.0)) / textureSize;\n"
    "  c04 = (screenCoords + vec2(-1.0, +0.0)) / textureSize;\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c06 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c07 = (screenCoords + vec2(+2.0, +0.0)) / textureSize;\n"
    "  c08 = (screenCoords + vec2(-1.0, +1.0)) / textureSize;\n"
    "  c09 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  c11 = (screenCoords + vec2(+2.0, +1.0)) / textureSize;\n"
    "  c13 = (screenCoords + vec2(+0.0, +2.0)) / textureSize;\n"
    "  c14 = (screenCoords + vec2(+1.0, +2.0)) / textureSize;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cut3UpscalePass0Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "#define EPSILON 0.02\n"
    "\n"
    "precision lowp float;\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "\n"
    "varying HIGHP vec2 c01;\n"
    "varying HIGHP vec2 c02;\n"
    "varying HIGHP vec2 c04;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c07;\n"
    "varying HIGHP vec2 c08;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "varying HIGHP vec2 c11;\n"
    "varying HIGHP vec2 c13;\n"
    "varying HIGHP vec2 c14;\n"
    "\n"
    "lowp float maxOf(lowp vec4 values) {\n"
    "  return max(max(values.x, values.y), max(values.z, values.w));\n"
    "}\n"
    "\n"
    "lowp float luma(lowp vec3 v) {\n"
    "#if EDGE_USE_FAST_LUMA\n"
    "  lowp float result = v.g;\n"
    "#else\n"
    "  lowp float result = dot(v, vec3(0.299, 0.587, 0.114));\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp float quickPackBools2(bvec2 values) {\n"
    "  return dot(vec2(values), vec2(0.5, 0.25));\n"
    "}\n"
    "\n"
    "lowp float quickPackFloats2(lowp vec2 values) {\n"
    "  return dot(floor(values * vec2(12.0) + vec2(0.5)), vec2(0.0625, 0.00390625));\n"
    "}\n"
    "\n"
    "struct Quad {\n"
    "  lowp vec4 scores;\n"
    "  lowp float maxEdgeContrast;\n"
    "};\n"
    "\n"
    "Quad quad(lowp vec4 values) {\n"
    "  lowp vec4 edges = values.xyzx - values.ywwz;\n"
    "\n"
    "  Quad result;\n"
    "  result.scores = vec4(\n"
    "    abs(edges.x + edges.z),\n"
    "    abs(edges.w + edges.y),\n"
    "    max(abs(edges.x - edges.y), abs(edges.w - edges.z)),\n"
    "    max(abs(edges.x + edges.w), abs(edges.y + edges.z))\n"
    "  );\n"
    "  result.maxEdgeContrast = maxOf(abs(edges));\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp int computePattern(lowp vec4 scores, lowp vec4 neighborsScores) {\n"
    "  lowp float maxOrthogonal = max(scores.x, scores.y);\n"
    "  lowp float maxDiagonal = max(scores.z, scores.w);\n"
    "\n"
    "  bool isDiagonal = maxDiagonal > maxOrthogonal;\n"
    "\n"
    "  scores += 0.25 * neighborsScores;\n"
    "\n"
    "  lowp int result = 0;\n"
    "  if (!isDiagonal) {\n"
    "    if (scores.x > scores.y + EDGE_MIN_VALUE) {\n"
    "      result = 1;\n"
    "    } else if (scores.y > scores.x + EDGE_MIN_VALUE) {\n"
    "      result = 2;\n"
    "    }\n"
    "  } else {\n"
    "    if (scores.z > scores.w + EDGE_MIN_VALUE) {\n"
    "      result = 3;\n"
    "    } else if (scores.w > scores.z + EDGE_MIN_VALUE) {\n"
    "      result = 4;\n"
    "    }\n"
    "  }\n"
    "\n"
    "  lowp vec2 maxScores = isDiagonal ? vec2(maxOrthogonal, maxDiagonal) : vec2(maxDiagonal, maxOrthogonal);\n"
    "  if (maxScores.y <= max((1.0 + HARD_EDGES_THRESHOLD) * maxScores.x, EDGE_MIN_VALUE)) {\n"
    "    result = -result;\n"
    "  }\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp int findPattern(Quad quad) {\n"
    "  return computePattern(quad.scores, vec4(0.0));\n"
    "}\n"
    "\n"
    "lowp int findPattern(Quad quads[5]) {\n"
    "  lowp vec4 scores = quads[0].scores;\n"
    "  lowp vec4 adjustments = vec4(0.0);\n"
    "  adjustments += quads[1].scores;\n"
    "  adjustments += quads[2].scores;\n"
    "  adjustments += quads[3].scores;\n"
    "  adjustments += quads[4].scores;\n"
    "  return computePattern(scores, adjustments);\n"
    "}\n"
    "\n"
    "lowp float softEdgeWeight(lowp float a, lowp float b, lowp float c, lowp float d) {\n"
    "  lowp float result = 0.0;\n"
    "  lowp float diff = abs(b - c);\n"
    "  result += (diff / clamp(abs(a - c), diff + EPSILON, 1.0));\n"
    "  result -= (diff / clamp(abs(b - d), diff + EPSILON, 1.0));\n"
    "  return clamp(2.0 * result, -1.0, 1.0);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t01 = texture2D(texture, c01).rgb;\n"
    "  lowp vec3 t02 = texture2D(texture, c02).rgb;\n"
    "  lowp vec3 t04 = texture2D(texture, c04).rgb;\n"
    "  lowp vec3 t05 = texture2D(texture, c05).rgb;\n"
    "  lowp vec3 t06 = texture2D(texture, c06).rgb;\n"
    "  lowp vec3 t07 = texture2D(texture, c07).rgb;\n"
    "  lowp vec3 t08 = texture2D(texture, c08).rgb;\n"
    "  lowp vec3 t09 = texture2D(texture, c09).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "  lowp vec3 t11 = texture2D(texture, c11).rgb;\n"
    "  lowp vec3 t13 = texture2D(texture, c13).rgb;\n"
    "  lowp vec3 t14 = texture2D(texture, c14).rgb;\n"
    "\n"
    "  lowp float l01 = luma(t01);\n"
    "  lowp float l02 = luma(t02);\n"
    "  lowp float l04 = luma(t04);\n"
    "  lowp float l05 = luma(t05);\n"
    "  lowp float l06 = luma(t06);\n"
    "  lowp float l07 = luma(t07);\n"
    "  lowp float l08 = luma(t08);\n"
    "  lowp float l09 = luma(t09);\n"
    "  lowp float l10 = luma(t10);\n"
    "  lowp float l11 = luma(t11);\n"
    "  lowp float l13 = luma(t13);\n"
    "  lowp float l14 = luma(t14);\n"
    "\n"
    "  Quad quads[5];\n"
    "  quads[0] = quad(vec4(l05, l06, l09, l10));\n"
    "  quads[1] = quad(vec4(l01, l02, l05, l06));\n"
    "  quads[2] = quad(vec4(l06, l07, l10, l11));\n"
    "  quads[3] = quad(vec4(l09, l10, l13, l14));\n"
    "  quads[4] = quad(vec4(l04, l05, l08, l09));\n"
    "\n"
    "  lowp int pattern = findPattern(quads);\n"
    "\n"
    "  lowp vec4 neighborContrasts = max(\n"
    "    vec4(quads[0].maxEdgeContrast),\n"
    "    vec4(quads[1].maxEdgeContrast, quads[2].maxEdgeContrast, quads[3].maxEdgeContrast, quads[4].maxEdgeContrast)\n"
    "  );\n"
    "\n"
    "  lowp vec4 mainValues = vec4(l05, l06, l09, l10);\n"
    "  lowp vec4 mainEdges = abs(mainValues.xyzx - mainValues.ywwz);\n"
    "  bvec4 neighborConnections = greaterThanEqual(mainEdges, HARD_EDGES_SEARCH_MIN_CONTRAST * neighborContrasts);\n"
    "\n"
    "  lowp ivec4 neighborPatterns = ivec4(\n"
    "    findPattern(quads[1]),\n"
    "    findPattern(quads[2]),\n"
    "    findPattern(quads[3]),\n"
    "    findPattern(quads[4])\n"
    "  );\n"
    "  neighborPatterns *= ivec4(neighborConnections);\n"
    "\n"
    "  bool vertical = any(equal(neighborPatterns.xz, ivec2(1)));\n"
    "  bool horizontal = any(equal(neighborPatterns.yw, ivec2(2)));\n"
    "  bool corner = vertical && horizontal;\n"
    "  bool opposite = any(equal(neighborPatterns, ivec4(pattern == 3 ? 4 : 3)));\n"
    "  bool isTriangle = pattern >= 3;\n"
    "\n"
    "  bool reject = (isTriangle && (opposite || corner)) || !any(neighborConnections);\n"
    "\n"
    "  lowp vec4 result = vec4(0.0);\n"
    "\n"
    "#if SOFT_EDGES_SHARPENING\n"
    "  lowp vec4 softEdges = vec4(\n"
    "    softEdgeWeight(l04, l05, l06, l07),\n"
    "    softEdgeWeight(l02, l06, l10, l14),\n"
    "    softEdgeWeight(l08, l09, l10, l11),\n"
    "    softEdgeWeight(l01, l05, l09, l13)\n"
    "  );\n"
    "\n"
    "  result.y = quickPackFloats2(softEdges.xy * 0.5 + vec2(0.5));\n"
    "  result.z = quickPackFloats2(softEdges.zw * 0.5 + vec2(0.5));\n"
    "#endif\n"
    "\n"
    "  if (pattern > 0 && reject) {\n"
    "    pattern = -pattern;\n"
    "  }\n"
    "\n"
    "  result.x = float(pattern + 4) / 8.0;\n"
    "  gl_FragColor = result;\n"
    "}";

const std::string ShaderManager::cut3UpscalePass1Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 dc;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  HIGHP vec2 screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  passCoords = c05;\n"
    "  dc = vec2(1.0) / textureSize;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cut3UpscalePass1Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "precision lowp float;\n"
    "\n"
    "#define EPSILON 0.02\n"
    "\n"
    "const lowp float STEP = 0.5 / float(HARD_EDGES_SEARCH_MAX_DISTANCE);\n"
    "const lowp float HSTEP = (STEP * 0.5);\n"
    "\n"
    "uniform lowp sampler2D previousPass;\n"
    "\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 dc;\n"
    "\n"
    "lowp float quickPackBools2(bvec2 values) {\n"
    "  return dot(vec2(values), vec2(0.5, 0.25));\n"
    "}\n"
    "\n"
    "lowp float quickPackFloats2(lowp vec2 values) {\n"
    "  return dot(floor(values * vec2(12.0) + vec2(0.5)), vec2(0.0625, 0.00390625));\n"
    "}\n"
    "\n"
    "lowp vec2 quickUnpackFloats2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return result / 12.0;\n"
    "}\n"
    "\n"
    "bvec2 quickUnpackBools2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return greaterThan(result, vec2(0.5));\n"
    "}\n"
    "\n"
    "lowp int fetchPattern(lowp float value) {\n"
    "  return int(value * 8.0 + 0.5) - 4;\n"
    "}\n"
    "\n"
    "lowp vec2 walk(\n"
    "  lowp sampler2D previousPass,\n"
    "  HIGHP vec2 baseCoords,\n"
    "  HIGHP vec2 direction,\n"
    "  lowp vec2 results,\n"
    "  lowp int continuePattern\n"
    ") {\n"
    "  lowp vec2 result = vec2(0.0, 0.0);\n"
    "  for (lowp int i = 1; i <= HARD_EDGES_SEARCH_MAX_DISTANCE; i++) {\n"
    "    HIGHP vec2 coords = baseCoords + direction * float(i);\n"
    "    lowp int currentPattern = fetchPattern(texture2D(previousPass, coords).x);\n"
    "\n"
    "    if (currentPattern == 3) {\n"
    "      result.y = results.x;\n"
    "    } else if (currentPattern == 4) {\n"
    "      result.y = results.y;\n"
    "    }\n"
    "\n"
    "    if (currentPattern == 3 || currentPattern == 4) {\n"
    "      result.x += HSTEP;\n"
    "    } else if (currentPattern == continuePattern) {\n"
    "      result.x += STEP;\n"
    "    }\n"
    "\n"
    "    if (currentPattern != continuePattern) { break; }\n"
    "  }\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp float blendWeights(lowp vec2 d1, lowp vec2 d2) {\n"
    "  const float MAX_DOUBLE_DISTANCE = float(HARD_EDGES_SEARCH_MAX_DISTANCE) * STEP;\n"
    "  const float MAX_DISTANCE = STEP * float(HARD_EDGES_SEARCH_MAX_DISTANCE / 2) + HSTEP;\n"
    "\n"
    "  lowp float result = 0.0;\n"
    "\n"
    "  lowp float totalDistance = d1.x + d2.x;\n"
    "  lowp float d1Ratio = d1.x / totalDistance;\n"
    "\n"
    "  if (totalDistance <= EPSILON) {\n"
    "    result = 0.0;\n"
    "  } else if (totalDistance <= MAX_DOUBLE_DISTANCE) {\n"
    "    result = (d1.x < d2.x) ? mix(d1.y, 0.0, 2.0 * d1Ratio) : mix(0.0, d2.y, (d1Ratio - 0.5) * 2.0);\n"
    "  } else if (d1.x <= MAX_DISTANCE) {\n"
    "    result = mix(d1.y, 0.0, d1.x / MAX_DISTANCE);\n"
    "  } else if (d2.x <= MAX_DISTANCE) {\n"
    "    result = mix(d2.y, 0.0, d2.x / MAX_DISTANCE);\n"
    "  }\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 previousPassPixel = texture2D(previousPass, passCoords).xyz;\n"
    "  lowp int pattern = fetchPattern(previousPassPixel.x);\n"
    "\n"
    "  lowp vec2 resultN = vec2(0.0, 0.0);\n"
    "  lowp vec2 resultS = vec2(0.0, 0.0);\n"
    "  lowp vec2 resultW = vec2(0.0, 0.0);\n"
    "  lowp vec2 resultE = vec2(0.0, 0.0);\n"
    "\n"
    "  if (pattern == 1 || pattern == 3 || pattern == 4) {\n"
    "    resultN = walk(previousPass, passCoords, vec2(0.0, -dc.y), vec2(-1.0, +1.0), 1);\n"
    "    resultS = walk(previousPass, passCoords, vec2(0.0, +dc.y), vec2(+1.0, -1.0), 1);\n"
    "  }\n"
    "  if (pattern == 2 || pattern == 3 || pattern == 4) {\n"
    "    resultW = walk(previousPass, passCoords, vec2(-dc.x, 0.0), vec2(-1.0, +1.0), 2);\n"
    "    resultE = walk(previousPass, passCoords, vec2(+dc.x, 0.0), vec2(+1.0, -1.0), 2);\n"
    "  }\n"
    "  lowp vec4 edgesWeights[4];\n"
    "\n"
    "  if (pattern == 1) {\n"
    "    edgesWeights[0] = vec4(resultN, resultS + vec2(STEP, 0.0));\n"
    "    edgesWeights[2] = vec4(resultN + vec2(STEP, 0.0), resultS);\n"
    "  } else if (pattern == 2) {\n"
    "    edgesWeights[3] = vec4(resultW, resultE + vec2(STEP, 0.0));\n"
    "    edgesWeights[1] = vec4(resultW + vec2(STEP, 0.0), resultE);\n"
    "  } else if (pattern == 3) {\n"
    "    edgesWeights[0] = vec4(resultN, vec2(HSTEP, 1.0));\n"
    "    edgesWeights[2] = vec4(vec2(HSTEP, -1.0), resultS);\n"
    "    edgesWeights[3] = vec4(resultW, vec2(HSTEP, 1.0));\n"
    "    edgesWeights[1] = vec4(vec2(HSTEP, -1.0), resultE);\n"
    "  } else if (pattern == 4) {\n"
    "    edgesWeights[0] = vec4(resultN, vec2(HSTEP, -1.0));\n"
    "    edgesWeights[2] = vec4(vec2(HSTEP, 1.0), resultS);\n"
    "    edgesWeights[3] = vec4(resultW, vec2(HSTEP, -1.0));\n"
    "    edgesWeights[1] = vec4(vec2(HSTEP, 1.0), resultE);\n"
    "  }\n"
    "  lowp vec4 edges = vec4(\n"
    "    blendWeights(edgesWeights[0].xy, edgesWeights[0].zw),\n"
    "    blendWeights(edgesWeights[1].xy, edgesWeights[1].zw),\n"
    "    blendWeights(edgesWeights[2].xy, edgesWeights[2].zw),\n"
    "    blendWeights(edgesWeights[3].xy, edgesWeights[3].zw)\n"
    "  );\n"
    "\n"
    "#if SOFT_EDGES_SHARPENING\n"
    "  lowp vec4 softEdges = 2.0 * SOFT_EDGES_SHARPENING_AMOUNT * vec4(\n"
    "    quickUnpackFloats2(previousPassPixel.y + 0.001953125) - vec2(0.5),\n"
    "    quickUnpackFloats2(previousPassPixel.z + 0.001953125) - vec2(0.5)\n"
    "  );\n"
    "\n"
    "  edges = clamp(edges + softEdges, min(edges, softEdges), max(edges, softEdges));\n"
    "#endif\n"
    "\n"
    "  lowp int originalPattern = pattern >= 0 ? pattern : -pattern;\n"
    "  if (originalPattern == 3) {\n"
    "    edges = vec4(-edges.x, edges.w, -edges.z, edges.y);\n"
    "  }\n"
    "\n"
    "  gl_FragColor = vec4(\n"
    "    quickPackBools2(bvec2(originalPattern >= 3, originalPattern == 3)),\n"
    "    quickPackFloats2(edges.xy * 0.5 + vec2(0.5)),\n"
    "    quickPackFloats2(edges.zw * 0.5 + vec2(0.5)),\n"
    "    1.0\n"
    "  );\n"
    "}";


const std::string ShaderManager::cut3UpscalePass2Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying lowp float cutMaxSharpness;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "void main() {\n"
    "  cutMaxSharpness = clamp(1.0 - 1.0 / screenDensity, 0.0, 1.0);\n"
    "  HIGHP vec2 coords = vCoordinate * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c05 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c06 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c09 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  passCoords = c05;\n"
    "  gl_Position = vPosition;\n"
    "}";

const std::string ShaderManager::cut3UpscalePass2Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "#endif\n"
    "\n"
    "precision lowp float;\n"
    "\n"
    "#define EPSILON 0.02\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "uniform lowp sampler2D previousPass;\n"
    "\n"
    "varying lowp float cutMaxSharpness;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c05;\n"
    "varying HIGHP vec2 c06;\n"
    "varying HIGHP vec2 c09;\n"
    "varying HIGHP vec2 c10;\n"
    "\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return v.g;\n"
    "}\n"
    "\n"
    "struct Pixels {\n"
    "  lowp vec3 p0;\n"
    "  lowp vec3 p1;\n"
    "  lowp vec3 p2;\n"
    "  lowp vec3 p3;\n"
    "};\n"
    "\n"
    "struct ShapeWeights {\n"
    "  lowp vec3 weights;\n"
    "  lowp vec3 midPoints;\n"
    "};\n"
    "\n"
    "struct Pattern {\n"
    "  Pixels pixels;\n"
    "  lowp vec3 weights;\n"
    "  lowp vec3 midPoints;\n"
    "  lowp vec3 baseSharpness;\n"
    "};\n"
    "\n"
    "struct Flags {\n"
    "  bool flip;\n"
    "  bool triangle;\n"
    "  lowp vec4 edgeWeight;\n"
    "};\n"
    "\n"
    "lowp vec2 quickUnpackFloats2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 16.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return result / 12.0;\n"
    "}\n"
    "\n"
    "bvec2 quickUnpackBools2(lowp float value) {\n"
    "  lowp vec2 result = vec2(0.0);\n"
    "  lowp float current = value;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.x = floor(current);\n"
    "  current -= result.x;\n"
    "\n"
    "  current *= 2.0;\n"
    "  result.y = floor(current);\n"
    "  current -= result.y;\n"
    "\n"
    "  return greaterThan(result, vec2(0.5));\n"
    "}\n"
    "\n"
    "Flags parseFlags(lowp vec3 flagsPixel) {\n"
    "  Flags flags;\n"
    "  flags.edgeWeight = clamp(\n"
    "    vec4(quickUnpackFloats2(flagsPixel.y + 0.001953125), quickUnpackFloats2(flagsPixel.z + 0.001953125)),\n"
    "    EPSILON,\n"
    "    1.0 - EPSILON\n"
    "  );\n"
    "  bvec2 boolFlags = quickUnpackBools2(flagsPixel.x + 0.125);\n"
    "  flags.triangle = boolFlags.x;\n"
    "  flags.flip = boolFlags.y;\n"
    "  return flags;\n"
    "}\n"
    "\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n"
    "}\n"
    "\n"
    "lowp float sharpness(lowp float l1, lowp float l2) {\n"
    "#if USE_DYNAMIC_BLEND\n"
    "  const lowp float blendDiffInv = 1.0 / (BLEND_MAX_CONTRAST_EDGE - BLEND_MIN_CONTRAST_EDGE);\n"
    "  lowp float lumaDiff = abs(l1 - l2);\n"
    "  lowp float contrast = clamp((lumaDiff - BLEND_MIN_CONTRAST_EDGE) * blendDiffInv, 0.0, 1.0);\n"
    "  lowp float result = mix(BLEND_MIN_SHARPNESS * 0.5, BLEND_MAX_SHARPNESS * 0.5, contrast);\n"
    "#else\n"
    "  lowp float result = STATIC_BLEND_SHARPNESS * 0.5;\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lowp float adjustMidpoint(lowp float x, lowp float midPoint) {\n"
    "  lowp float result = 0.0;\n"
    "  result += clamp(x / midPoint, 0.0, 1.0);\n"
    "  result += clamp((x - midPoint) / (1.0 - midPoint), 0.0, 1.0);\n"
    "  return 0.5 * result;\n"
    "}\n"
    "\n"
    "lowp vec3 blend(lowp vec3 a, lowp vec3 b, lowp float t, lowp float midPoint, lowp float baseSharpness) {\n"
    "  lowp float sharpness = baseSharpness * sharpness(luma(a), luma(b));\n"
    "  sharpness = clamp(sharpness, 0.0, 0.5 * cutMaxSharpness);\n"
    "  lowp float nt = adjustMidpoint(t, midPoint);\n"
    "  nt = clamp((nt - sharpness) / (1.0 - 2.0 * sharpness), 0.0 , 1.0);\n"
    "  return mix(a, b, nt);\n"
    "}\n"
    "\n"
    "Pattern pattern(Pixels pixels, lowp vec4 edgeWeights, bool triangle, lowp vec2 pxCoords) {\n"
    "  Pattern result;\n"
    "\n"
    "  bool firstTriangle = triangle && pxCoords.x + pxCoords.y <= 1.0;\n"
    "  bool secondTriangle = triangle && !firstTriangle;\n"
    "\n"
    "  lowp vec2 midPoints = vec2(0.0);\n"
    "\n"
    "  if (secondTriangle) {\n"
    "    pxCoords = vec2(1.0 - pxCoords.y, 1.0 - pxCoords.x);\n"
    "    pixels = Pixels(pixels.p3, pixels.p1, pixels.p2, pixels.p0);\n"
    "    edgeWeights = vec4(1.0) - edgeWeights.yxwz;\n"
    "  }\n"
    "\n"
    "  if (triangle) {\n"
    "    lowp float coordsSum = pxCoords.x + pxCoords.y;\n"
    "    midPoints = vec2(\n"
    "      edgeWeights.x * edgeWeights.w * coordsSum / (edgeWeights.w * pxCoords.x + edgeWeights.x * pxCoords.y),\n"
    "      0.5 + 0.5 * clamp(-edgeWeights.x + edgeWeights.y - edgeWeights.z + edgeWeights.w, -1.0, 1.0)\n"
    "    );\n"
    "    pxCoords = vec2(coordsSum, pxCoords.y / coordsSum);\n"
    "  } else {\n"
    "    midPoints = vec2(\n"
    "      mix(edgeWeights.x, edgeWeights.z, pxCoords.y),\n"
    "      mix(edgeWeights.w, edgeWeights.y, pxCoords.x)\n"
    "    );\n"
    "  }\n"
    "\n"
    "  result.weights = pxCoords.xxy;\n"
    "  result.midPoints = midPoints.xxy;\n"
    "  result.baseSharpness = vec3(1.0, 1.0, float(!triangle));\n"
    "  result.pixels = Pixels(\n"
    "    pixels.p0,\n"
    "    pixels.p1,\n"
    "    triangle ? pixels.p0 : pixels.p2,\n"
    "    triangle ? pixels.p2 : pixels.p3\n"
    "  );\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t05 = texture2D(texture, c05).rgb;\n"
    "  lowp vec3 t06 = texture2D(texture, c06).rgb;\n"
    "  lowp vec3 t09 = texture2D(texture, c09).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "\n"
    "  lowp vec3 flagsPixel = texture2D(previousPass, passCoords).xyz;\n"
    "  Flags flags = parseFlags(flagsPixel);\n"
    "  Pixels pixels = Pixels(t05, t06, t09, t10);\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "  lowp vec4 edges = flags.edgeWeight;\n"
    "\n"
    "  if (flags.flip) {\n"
    "    pixels = Pixels(pixels.p1, pixels.p0, pixels.p3, pixels.p2);\n"
    "    pxCoords.x = 1.0 - pxCoords.x;\n"
    "  }\n"
    "\n"
    "  Pattern pattern = pattern(pixels, edges, flags.triangle, pxCoords);\n"
    "\n"
    "  lowp vec3 final = blend(\n"
    "    blend(pattern.pixels.p0, pattern.pixels.p1, pattern.weights.x, pattern.midPoints.x, pattern.baseSharpness.x),\n"
    "    blend(pattern.pixels.p2, pattern.pixels.p3, pattern.weights.y, pattern.midPoints.y, pattern.baseSharpness.y),\n"
    "    pattern.weights.z,\n"
    "    pattern.midPoints.z,\n"
    "    pattern.baseSharpness.z\n"
    "  );\n"
    "\n"
    "  gl_FragColor = vec4(final.rgb, 1.0);\n"
    "}";

ShaderManager::Chain ShaderManager::getShader(const ShaderManager::Config& config) {
    switch (config.type) {
    case Type::SHADER_DEFAULT: {
        return { { { defaultShaderVertex, defaultShaderFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_CRT: {
        return { { { defaultShaderVertex, crtShaderFragment, true, 1.0 } } , true };
    }

    case Type::SHADER_LCD: {
        return { { {defaultShaderVertex, lcdShaderFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_SHARP: {
        return { { { defaultShaderVertex, defaultSharpFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_UPSCALE_CUT: {
        std::string defines = buildDefines(cutUpscaleParams, config.params);
        return { { {
            defines + cutUpscaleVertex,
            defines + cutUpscaleFragment,
            false,
            1.0
        } } , false };
    }

    case Type::SHADER_UPSCALE_CUT2: {
        std::string defines = buildDefines(cut2UpscaleParams, config.params);
        return {
            {
                {
                    defines + cut2UpscalePass0Vertex,
                    defines + cut2UpscalePass0Fragment,
                    false,
                    1.0
                },
                {
                    defines + cut2UpscalePass1Vertex,
                    defines + cut2UpscalePass1Fragment,
                    false,
                    1.0
                }
            },
            false
        };
    }

    case Type::SHADER_UPSCALE_CUT3: {
        std::string defines = buildDefines(cut3UpscaleParams, config.params);
        return {
            {
                {
                    defines + cut3UpscalePass0Vertex,
                    defines + cut3UpscalePass0Fragment,
                    false,
                    1.0
                    },
                {
                    defines + cut3UpscalePass1Vertex,
                    defines + cut3UpscalePass1Fragment,
                    false,
                    1.0
                    },
                {
                    defines + cut3UpscalePass2Vertex,
                    defines + cut3UpscalePass2Fragment,
                    false,
                    1.0
                },
            },
            false
        };
    }
}
}

std::string ShaderManager::buildDefines(
    std::unordered_map<std::string, std::string> baseParams,
    std::unordered_map<std::string, std::string> customParams
) {
    customParams.insert(baseParams.begin(), baseParams.end());

    std::string result;
    std::for_each(customParams.begin(), customParams.end(), [&result] (auto param) {
        result += "#define " + param.first + " " + param.second + "\n";
    });

    return result + "\n";
}

bool ShaderManager::Chain::operator==(const ShaderManager::Chain &other) const {
    return this->passes == other.passes && this->linearTexture == other.linearTexture;
}

bool ShaderManager::Chain::operator!=(const ShaderManager::Chain &other) const {
    return !(*this == other);
}

bool ShaderManager::Pass::operator==(const ShaderManager::Pass &other) const {
    return this->linear == other.linear && this->scale == other.scale &&
           this->vertex == other.vertex && this->fragment == other.fragment;
}
} //namespace libretrodroid
